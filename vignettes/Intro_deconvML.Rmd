---
title: "How to use deconvML package"
author: "Alicia Gómez Pascual"
date: "04/04/2020"
output: rmarkdown::html_vignette
bibliography: references.bib
link-citations: yes
vignette: >
  %\VignetteIndexEntry{How to use deconvML package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 1. Introduction and objectives

The advent of single-cell genomics represents a turning point in cell biology. For the first time, we can assay the expression level of every gene in the genome across thousands of individual cells in a single experiment [@trapnell2015defining]. This type of study leads us to ask ourselves questions such as: what cell types does your dataset have? how big are they? what are the most active genes in cell type X? 

To resolve these and many other questions, the deconvML package has been developed. With this package we will be able to know the most relevant information of our datasets, ask different questions that concern the different cell types and tissues that compose it, know the methods that we can apply to our dataset to estimate the active genes and, ultimately, ask which ones are those genes for a certain cell type in a tissue. Therefore, we will propose different questions about a single-cell data set and we will solve them with the deconvML package. 



## 2.Materials

The operation of this package is focused on datasets with a loom-type structure, since these have the main advantage that loom objects are merely connections to a file on disk, which enables scaling to massive datasets with low memory consumption. The loom file is simply an HDF5 file with a strict structure imposed on it, consists of a container for six sub-objects: one dataset (matrix) and five groups (layers, row_attrs, col_attrs, row_graphs, and col_graphs). For more information on this type of object, see: <https://satijalab.org/loomR/loomR_tutorial.html>.

In this documentation, we will use as data set with this type of structure, Zheisel, a mouse brain atlas of cell types from the Linnarsson Lab (data available at: <http://mousebrain.org/downloads.html>. For a first contact with this repository and, in general with single-cell data, the documentation "Processing raw data from Zheisel to get cell type specificity for genes" by Juan A. Botía is recommended, where the data is examined of single-cell focused on a single brain region.



## 3.Methodology

First, we install the deconvML package through the following command: 

```{r, eval=FALSE}
devtools::install_github('AliciaGP/deconvML')
```


```{r}
library(deconvML)
```

Next, we load the Zheisel dataset from LOOM R file through package `loomR`.

```{r}
library("loomR")
zheisel <- connect(filename = "/home/aligo/zheisel/l5_all.loom", mode = "r+")  
```

Since the deconvML package would allow examining different datasets, first of all we are going to check the ones we have loaded in our global environment. In this case, we only have the Zheisel dataset but we could load as many datasets as we wanted.

```{r}
getDataSetList()
```

At this point, it would be advisable to have a first contact with this dataset consulting its main characteristics. To do this, we use the function *getDataSetInfo*.

```{r}
getDataSetInfo(zheisel)
```

As we can see, this dataset is made up of 160796 cells and 27998 genes. These cells are classified into up to 7 cell types, which can be found in up to 23 tissues. Consequently, the first questions that arise are: what cell types is my data set composed of? What tissues are these cell types part of? To answer these questions we apply the *getCellTypesInDataSet* and *getTissueTypesInDataSet* functions.

```{r}
cellTypesZheisel <- getCellTypesInDataSet(zheisel)
cellTypesZheisel
```

```{r}
tissueTypesZheisel <- getTissueTypesInDataSet(zheisel)
tissueTypesZheisel 
```

In this way, I could be interested to know which are the most active genes for a specific cell type, such as astrocytes, in a specific tissue, such as the amygdala. However, to estimate the active genes there are different methods and I need to know which ones I can apply to my dataset based on their characteristics. To do this, we apply the function getActiveGeneMethod.

```{r}
methodsZheisel <- getActiveGeneMethod (zheisel)
methodsZheisel
```

In our case, we can apply both VariationCoefficient and RawExpression (for more information on these methods consult the documentation: "Processing raw data from Zheisel to get cell type specificity for genes" by Juan A. Botía).

Once the methods available as the tissues and cell types of a specific dataset are known through the functions getActiveGeneMethod, getTissueTypesInDataSet and getCellTypesInDataSet respectively, we can proceed to estimate the active genes. In order to implement the function that performs it, called *getActiveGenesInCellType*, we first pre-calculate the active gene matrixes for each of the tissues. Each matrix will be composed of as many rows as cell types, each one composed of as many 1 as active genes and as many 0 as inactive genes for this tissue. In this case, we will create two matrixes for each of the tissues since we will execute each of the available methods for this data set. Finally, each of these matrixes will be saved as an rds file with the name "dataset_tissue_method.rds" (these files are also available in the github repository). 


The steps to obtain these matrixes are detailed below:

**1.Collect the information necesary**. On the one hand, we will need the expression data matrix, already available from the dataset. On the other hand, we will need the tissue types, cell types and available methods, which will be obtained by calling the previously described functions. Obtained the information, we are going to verify that it is correct, otherwise, the function would end here.

**2.Create each matrix**. From the main matrix of this dataset, we will create one matrix composed of as many rows as cells belong to a tissue and another one composed of as many rows as cells belong to a cell type. Next, we will select the matching rows between them, that is, they belong to a specific tissue and a specific cell type. This matrix will be used to estimate the active genes using two methods: RawExpression and VariationCoefficient. From each method, we will obtain the ids of the active genes, that is, those that are expressed above 0.5 for a visibility value of 0.05 (default value) or that have a coefficient of variation above 0.05, depending on the method used.

**3.Build a boolean matrix.** At this point, we have the ids of the active genes for a specific cell type within a specific tissue obtained with each method for a specific dataset. But we want to build a boolean matrix, then we have to represent the active genes by ones and zeros. To do this, we will create a vector of the same length as the number of columns in our smatrix, that is, the number of genes, and what we will complete with zeros. Next, we will check the positions occupied by the active genes calculated in the complete list of genes and replace those positions with ones. Each created vector will be included as an independent row in a dataframe, in this way, we will create a matrix with as many rows as cell types and as many columns as genes. We carry out this process for each method so we will simultaneously create two dataframes for each tissue, one for each method.

**4.Repeat the process**. After evaluating all the cell types within a tissue, we will save the files, initialize the variables again and continue with the rest of the tissues following the same procedure.

```{r}
calcActiveGenesInCellType <-  function(dataset){
 
# 1. Obtain the necessary data to execute the function.
  datasetName <- deparse(substitute(dataset))
  mymatrix <- dataset$matrix[, ]
 
  methods <- getActiveGeneMethod(dataset)
  tissues <- getTissueTypesInDataSet(dataset)
  cellTypes <- getCellTypesInDataSet(dataset)
  
  colnames(mymatrix) <- dataset$row.attrs$Gene[]
  rownames(mymatrix) <- dataset$col.attrs$CellID[]
  genes <- colnames(mymatrix)
  
  cv = function (x, na.rm = FALSE) {
        sd(x, na.rm = na.rm)/mean(x, na.rm = na.rm)}
  
  
# 2. Check if all data is available.
  
  if (is.null(methods)) stop("No methods available")
  if (is.null(tissues)) stop("No tissues available")
  if (is.null(cellTypes)) stop("No cell types available")
 
  
# 3. Access the expression data of each tissue.
  
  for (tissue in 1:length(tissues)) {
    
    tissueMatrix <- mymatrix[dataset$col.attrs$Tissue[] == tissues[tissue], ]
    example1 <- mymatrix[dataset$col.attrs$Tissue[] == tissues[1], ]
    
    # Two files will be created for each tissue, one for each method: RawExpression (RE) and VariationCoefficient (VC).
    activeGenesRETissue <- as.data.frame(matrix(numeric(), nrow = 0, ncol = length(genes)))
    activeGenesVCTissue <- as.data.frame(matrix(numeric(), nrow = 0, ncol = length(genes)))
       
    
# 3.1. And within each tissue, access the expression data of each cell type.
    
     for (type in 1:length(cellTypes)) {
       
      cellMatrix  <- mymatrix[dataset$col.attrs$Class[] == cellTypes[type], ]
      
      matchRows <- intersect(rownames(cellMatrix), rownames(tissueMatrix))
      tissueCellMatrix  <- as.matrix(cellMatrix[matchRows, ])
      
      
      # For each cell type, the active genes for each method will be saved (RE and VC).
      activeGenesRECellType <- c()
      activeGenesVCCellType <- c()
      
      
# 3.1.1 Apply RawExpression method.
      
      visibility  <- 0.05 # default value
      
      mask = colSums(tissueCellMatrix > 0.5)  > (visibility * nrow(tissueCellMatrix))
      IDactiveGenesRECellType <- genes[mask] 
      indexActiveGenesRECellTYpe <- match(IDactiveGenesRECellType, genes) 
      activeGenesRECellType <- replace(rep(0, length(genes)), indexActiveGenesRECellTYpe, 1)
      
     
# 3.1.2 Apply VariationCoefficient method.
      
      cvs <- apply(tissueCellMatrix, 2, cv, na.rm = T)
      IDactiveGenesVCCellType <- names(cvs[cvs > 0.05]) 
      indexActiveGenesVCCellTYpe  <- match(IDactiveGenesVCCellType, genes)
      activeGenesVCCellType <- replace(rep(0, length(genes)), indexActiveGenesVCCellTYpe, 1)
      
      
# 3.1.3. Add each vector as a row of its corresponding dataframe depending on the method.
      
      activeGenesRETissue <- rbind(activeGenesRETissue, activeGenesRECellType) 
      activeGenesVCTissue <- rbind(activeGenesVCTissue, activeGenesVCCellType)
     }
     
# 4. Save the two files created for each tissue with the corresponding name.
      
      rownames(activeGenesRETissue) <- cellTypes
      colnames(activeGenesRETissue) <- genes
      saveRDS(activeGenesRETissue, paste0(datasetName, "_", 
                                         tissues[tissue], "_", 
                                         "RawExpression.rds"))
      
      rownames(activeGenesVCTissue) <- cellTypes
      colnames(activeGenesVCTissue) <- genes
      saveRDS(activeGenesVCTissue, paste0(datasetName, "_", 
                                          tissues[tissue], "_", 
                                          "VariationCoefficient.rds"))
    }
  
  
# 5. Repeat the process for each tissue. 
  
  return("Completed process")  
}
```

```{r}
calcActiveGenesInCellType(zheisel)
```

Therefore, once the matrices are pre-calculated once for each data set, we will be able to know the active genes for any cell type in any tissue for a specific method. So for example, we are going to check the active genes for astrocytes in the amygdala as we mentioned before and we are going to compare the results with each of the methods.

```{r}
activeGenesExample1 <- vector(mode = "list", length = length(methodsZheisel))

for (method in 1:length(activeGenesExample1)) {
  
  activeGenes <- NULL
  activeGenes <- getActiveGenesInCellType("zheisel", "Amygd", "Astrocytes", methodsZheisel[method])
  
  activeGenesExample1[[method]] = activeGenes
  
}

names(activeGenesExample1) <- methodsZheisel
```

```{r}
cat ("The ", methodsZheisel[1], "method returns a total of", length(activeGenesExample1[[1]]), "active genes for the astrocyte cell type in the amygdala while the", methodsZheisel[2], "method returns a total of", length(activeGenesExample1[[2]]), "active genes for the same cell type in the same tissue.")
```


```{r}
intersectActiveGenes <- intersect(activeGenesExample1[[1]], activeGenesExample1[[2]])
cat("Both methods converge in the selection of", length(intersectActiveGenes), "active genes.")
```

Interestingly, both methods have selected the same genes and it would be expected that, as we decreased the visibility value used in the raw expression method, the number of selected active genes increased, which would also converge with those selected with the raw expression method. Therefore, we may be interested in using the raw expression method to select a smaller number of genes taking into account the default visibility value (0.05).


Similarly, we could also be interested in which cell type has more active genes than any available for a tissue, for example, the amygdala, for a certain method, for example RawExpression.

```{r}
activeGenesExample2 <- vector(mode = "list", length = length(cellTypesZheisel))

for (cellType in 1:length(activeGenesExample2)) {
  
  activeGenes <- NULL
  activeGenes <- getActiveGenesInCellType("zheisel", "Amygd", cellTypesZheisel[cellType], "RawExpression")
  activeGenesExample2[[cellType]] = activeGenes
  
}

names(activeGenesExample2) <- cellTypesZheisel
```

```{r}
numberActiveGenesExample2 <- as.data.frame(lengths(activeGenesExample2))
colnames(numberActiveGenesExample2) <- "NumberActiveGenes"
selectRowExample2 = which.max(numberActiveGenesExample2$NumberActiveGenes)

numberActiveGenesExample2
```

```{r}
cat("As we can see, the cell type with the highest number of active genes reaches", numberActiveGenesExample2[selectRowExample2,1], "active genes. It is the cellular type:", rownames(numberActiveGenesExample2)[selectRowExample2])
```

Finally, we will evaluate the number of active genes for the same cell type, astrocytes, in each of the tissues using a certain method, for example RawExpression.

```{r}
activeGenesExample3 <- vector(mode = "list", length = length(tissueTypesZheisel))

for (tissue in 1:length(activeGenesExample3)) {
  
  activeGenes <- NULL
  activeGenes <- getActiveGenesInCellType("zheisel", tissueTypesZheisel[tissue], "Astrocytes", "RawExpression")
  
  activeGenesExample3[[tissue]] = activeGenes
  
}

names(activeGenesExample3) <- tissueTypesZheisel
```

```{r}
numberActiveGenesExample3 <- as.data.frame(lengths(activeGenesExample3))
colnames(numberActiveGenesExample3) <- "NumberActiveGenes"
selectRowExample3 = which.max(numberActiveGenesExample3$NumberActiveGenes)

numberActiveGenesExample3
```

```{r}
cat("As we can see, the tissue in which astrocytes have a higher gene expression reaches", max(numberActiveGenesExample3), "active genes in the tissue type", rownames(numberActiveGenesExample3)[selectRowExample3])
```

In this way, questions of this type could be raised and resolved with deconvML package for single-cell data sets, an increasingly used type of data set.


## References:


